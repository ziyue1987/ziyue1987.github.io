<!DOCTYPE html>
<html lang="zh">
<head>
        
        <title>Disruptor使用指南</title>
        <meta charset="utf-8" />
                <link href="http://ziyue1987.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="HANBIN's FARM Full Atom Feed" />
                                        <link href="http://ziyue1987.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="HANBIN's FARM RSS Feed" />
                        <link href="http://ziyue1987.github.io/feeds/java.atom.xml" type="application/atom+xml" rel="alternate" title="HANBIN's FARM Categories Atom Feed" />
                        <link href="http://ziyue1987.github.io/feeds/java.rss.xml" type="application/rss+xml" rel="alternate" title="HANBIN's FARM Categories RSS Feed" />
                        

        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="../../../../theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/style.css" />
        <link rel="stylesheet" type="text/css" href="../../../../theme/pygment.css" />

        <script src="../../../../theme/js/libs/modernizr-2.6.2.min.js"></script>


          



        </head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="../../../..">HANBIN's FARM <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="../../../..">Home</a></li>

                                                  
              </ul>
            </div>

          <section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="../../../../pages/2013/09/22/disruptor-use-manual.html" rel="bookmark"
                   title="Permalink to Disruptor使用指南">Disruptor使用指南</a></h2>
                      
            </header>
            <footer class="post-info">
              <abbr class="published" title="2013-09-22T00:00:00">
                2013-09-22
              </abbr>
                            <address class="vcard author">
                By <a class="url fn" href="../../../../author/hanbin-zheng.html">Hanbin Zheng</a>
              </address>
                          </footer><!-- /.post-info -->
            <div class="entry-content">
              <p><img alt="Mou icon" src="http://ifeve.com/wp-content/uploads/2013/02/Disruptor-300x144.png" /></p>
<p><a>By Hanbin Zheng</a>                                </p>
<p><strong>声明：本文系博主原创，欢迎转载，但请注明作者和出处，谢谢！</strong> </p>
<ul>
<li><a href="#intruduction"><strong>Intruduction</strong></a><ul>
<li><a href="#lockvscas">Lock vs CAS</a></li>
<li><a href="#avoidfalsesharing">避免伪共享</a></li>
<li><a href="#linkedvsarray">Linked Queue vs Array Ringbuffer</a></li>
<li><a href="#catching">无时不刻的缓存</a></li>
</ul>
</li>
<li><a href="#component"><strong>Component</strong></a><ul>
<li><a href="#sequence">Sequence</a></li>
<li><a href="#ringbuffer">RingBuffer</a></li>
<li><a href="#sequencbarrier">SequenceBarrier</a></li>
<li><a href="#waitstrategy">WaitStrategy</a></li>
<li><a href="#batcheventprocessor">BatchEvenProcessor</a></li>
<li><a href="#workprocessor">WorkProcessor</a></li>
<li><a href="#workerpool">WorkerPool</a></li>
</ul>
</li>
<li><a href="#usecases"><strong>Use Cases</strong></a><ul>
<li><a href="#message">消息定义</a></li>
<li><a href="#producer">Producer</a></li>
<li><a href="#eventprocessor">EventProcessor及其依赖关系</a></li>
<li><a href="#onepublishertoonebatcheventprocessor">One Publisher to one BatchEventProcessor</a></li>
<li><a href="#onepublishertothreebatcheventprocessorspipeline">One Publisher to three BatchEventProcessors Pipeline</a></li>
<li><a href="#onepublishertothreebatcheventprocessorsmulticast">One Publisher to three BatchEventProcessors MultiCast</a></li>
<li><a href="#onepublishertotwoworkprocessors">One Publisher to two WorkProcessors</a></li>
<li><a href="#onepublishertotwoworkerpools">One Publisher to two WorkerPools</a></li>
</ul>
</li>
<li><a href="#end"><strong>结束语</strong></a></li>
</ul>
<h2><a name="intruduction" id="intruduction"></a>Intruduction</h2>
<p>Disruptor 是Java实现的用于线程间通信的消息组件。核心是一个Lock-free的Ringbuffer。我使用BlockingQueue进行了简单的对比测试，结果表明使用Disruptor来进行线程间通信的效率会高将近一倍。LMAX给出的数据是使用Disruptor能够在一个线程里每秒处理6百万订单。那么Disruptor为什么会如此快呢？通过参考Martin Fowler（Disruptor的开发者之一）的技术博客和Disruptor的源代码，可以总结出以下四条原因：</p>
<h3><a name="lockvscas" id="lockvscas"></a>Lock vs CAS</h3>
<p>关于CAS(compare and swap)请参考WIKIPEDIA相关条目<a href="http://en.wikipedia.org/wiki/Compare-and-swap">Compare and swap</a>。与大部分并发队列使用的Lock相比，CAS显然要快很多。CAS是CPU级别的指令，不需要像Lock一样需要OS的支持。
所以每次调用不需要kernel entry，也不需要context switch。当然，实现的复杂程度也相对提高了。</p>
<h3><a name="avoidfalsesharing" id="avoidfalsesharing"></a>避免伪共享</h3>
<p>关于伪共享请参考WIKIPEDIA相关条目<a href="http://en.wikipedia.org/wiki/False_sharing">False sharing</a>。为了避免伪共享带来的性能下降，Disruptor对一切可能存在伪共享的地方使用Padding将两个不想关的内存隔离到两个缓存行上。可能存在伪共享的地方包括两个不相关的线程共享变量之间以及不相关线程私有变量和想成共享变量。下面分别举例子说明。
在Disruptor的实现中，有一个多线程共享的计数组件Sequence，对Sequence的操作可以说是整个Disruptor的核心，关于Sequence，在下文介绍各个组件的时候还要详细说明。这里主要说明它是怎样避免伪共享的。主要代码如下：</p>
<div class="highlight"><pre><span class="k">static</span> <span class="n">final</span> <span class="kt">long</span> <span class="n">INITIAL_VALUE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1L</span><span class="p">;</span>
<span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="n">Unsafe</span> <span class="n">UNSAFE</span><span class="p">;</span>
<span class="n">private</span> <span class="k">static</span> <span class="n">final</span> <span class="kt">long</span> <span class="n">VALUE_OFFSET</span><span class="p">;</span>

<span class="k">static</span>
<span class="p">{</span>
    <span class="n">UNSAFE</span> <span class="o">=</span> <span class="n">Util</span><span class="p">.</span><span class="n">getUnsafe</span><span class="p">();</span>
    <span class="n">final</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="p">.</span><span class="n">arrayBaseOffset</span><span class="p">(</span><span class="kt">long</span><span class="p">[].</span><span class="n">class</span><span class="p">);</span>
    <span class="n">final</span> <span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">UNSAFE</span><span class="p">.</span><span class="n">arrayIndexScale</span><span class="p">(</span><span class="kt">long</span><span class="p">[].</span><span class="n">class</span><span class="p">);</span>
    <span class="n">VALUE_OFFSET</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="mi">7</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">private</span> <span class="n">final</span> <span class="kt">long</span><span class="p">[]</span> <span class="n">paddedValue</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">long</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>

<span class="p">.</span> <span class="p">.</span> <span class="p">.</span>   <span class="p">.</span> <span class="p">.</span> <span class="p">.</span>

<span class="n">public</span> <span class="kt">long</span> <span class="n">get</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">UNSAFE</span><span class="p">.</span><span class="n">getLongVolatile</span><span class="p">(</span><span class="n">paddedValue</span><span class="p">,</span> <span class="n">VALUE_OFFSET</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Sequence定义了一个长度为15的long类型数组，使用数组第八个元素计数，数组其他部分连同对象的头作为padding部分，保证在以64byte作为缓存行大小的CPU中，计数用元素不会与其他变量存在于同一个缓存行中。关于Java中对象在内存中具体怎样布局，可以参考<a href="http://www.amazon.cn/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E5%91%A8%E5%BF%97%E6%98%8E/dp/B00D2ID4PK/ref=sr_1_2?ie=UTF8&amp;qid=1379761486&amp;sr=8-2&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">深入理解Java虚拟机：JVM高级特性与最佳实践</a></p>
<p>另一个例子是关于线程私有变量的：</p>
<div class="highlight"><pre><span class="n">private</span> <span class="k">static</span> <span class="n">class</span> <span class="n">Padding</span>
<span class="p">{</span>
    <span class="cm">/** Set to -1 as sequence starting point */</span>
    <span class="n">public</span> <span class="kt">long</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">.</span><span class="n">INITIAL_VALUE</span><span class="p">,</span> <span class="n">cachedValue</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">.</span><span class="n">INITIAL_VALUE</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p5</span><span class="p">,</span> <span class="n">p6</span><span class="p">,</span> <span class="n">p7</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">private</span> <span class="n">final</span> <span class="n">Padding</span> <span class="n">pad</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Padding</span><span class="p">();</span>
</pre></div>


<p>这段代码用在单生产者的应用场景中。在这种应用场景下，这个计数器不需要是线程安全的，使用Sequence过于heavy了，但仍然需要通过padding将其与其他线程共享的变量隔离开来。p2到p7的作用就是这个。</p>
<h3><a name="linkedvsarray" id="linkedvsarray"></a>Linked Queue vs Array Ringbuffer</h3>
<p>Disruptor选择使用Array ringbuffer来构造lock-free队列，而不是选择Linked queue。</p>
<p>首先，数组是预分配的，这样不仅避免了Java GC带来的运行开销，而且对缓存来说更加友好，由于在ringbuffer上进行的操作是顺序执行的，保证了缓存命中率。使用Disruptor的时候，为了更好的利用ringbuffer的这个优点，需要将ringbuffer的元素设计的可重用，使生产者在生产消息或产生事件的时候尽量对ringbuffer元素中得属性进行更新，而不是新建。</p>
<p>其次，数组在定位元素的时候是使用索引，而链表在定位元素的时候使用对象引用（地址）。在lock-free队列中使用链表需要使用Double-CAS来克服ABA问题（关于double-CAS和ABA问题，请参coolshell上<a href="http://coolshell.cn/articles/8239.html">关于无锁队列的文章</a>），而在数组中，可以通过递增的序号来标示不同时刻访问的相同元素，可以很自然得克服ABA问题，在需要访问数组元素的时候，只要用需要将序号对数组大小取余就可以得到数组索引。在Disruptor中Sequence就充当了递增的序号的角色。每次对ringbuffer的访问都会导致相应的Sequence增加。需要注意的是，由于Sequence是递增的，所以在到达最大值以后，会溢出，编程最小的负数，但这通常不是问题，因为要使long类型递增到溢出，即使每秒钟1000 000 000次递增，也需要上百年时间。</p>
<h3><a name="catching" id="catching"></a>无时不刻的缓存</h3>
<p>为了高效，Disruptor可谓无所不用其极，它绝不会放过任何利用缓存的信息的机会，看一个例子。</p>
<div class="highlight"><pre><span class="n">public</span> <span class="kt">long</span> <span class="nf">next</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">throw</span> <span class="n">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;n must be &gt; 0&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">long</span> <span class="n">nextValue</span> <span class="o">=</span> <span class="n">pad</span><span class="p">.</span><span class="n">nextValue</span><span class="p">;</span>

    <span class="kt">long</span> <span class="n">nextSequence</span> <span class="o">=</span> <span class="n">nextValue</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">wrapPoint</span> <span class="o">=</span> <span class="n">nextSequence</span> <span class="o">-</span> <span class="n">bufferSize</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">cachedGatingSequence</span> <span class="o">=</span> <span class="n">pad</span><span class="p">.</span><span class="n">cachedValue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">wrapPoint</span> <span class="o">&gt;</span> <span class="n">cachedGatingSequence</span> <span class="o">||</span> <span class="n">cachedGatingSequence</span> <span class="o">&gt;</span> <span class="n">nextValue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">long</span> <span class="n">minSequence</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">wrapPoint</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">minSequence</span> <span class="o">=</span> <span class="n">Util</span><span class="p">.</span><span class="n">getMinimumSequence</span><span class="p">(</span><span class="n">gatingSequences</span><span class="p">,</span> <span class="n">nextValue</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="n">Thread</span><span class="p">.</span><span class="n">yield</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">pad</span><span class="p">.</span><span class="n">cachedValue</span> <span class="o">=</span> <span class="n">minSequence</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pad</span><span class="p">.</span><span class="n">nextValue</span> <span class="o">=</span> <span class="n">nextSequence</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">nextSequence</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个函数是在单生产者的应用场景下生产者获取n个可用元素时执行的代码。在Disruptor里，需要多线程共享的序号，用Sequence表示，它是线程安全的，但同时访问Sequence的效率会降低，而在单线程内使用的序列号，则使用long类型，它是相对高效的。得益于序列号是递增的，就可以使用long类型cache住访问Seqence的结构，优先使用cache住的序号，只有当cache住的序号不满足条件时，才去访问Sequence。</p>
<h2><a name="component" id="component"></a>Component</h2>
<h3><a name="sequence" id="sequence"></a>Sequence</h3>
<p>Sequence是Disruptor最核心的组件。生产者对RingBuffer的互斥访问，生产者与消费者之间的协调以及消费者之间的协调，都是通过Sequence实现。那么Sequence是什么呢？首先Sequence是一个递增的序号，说白了就是计数器；其次，由于需要在线程间共享，所以Sequence是引用传递，并且是线程安全的；再次，Sequence支持CAS；操作最后，为了提高效率，Sequence通过padding来避免伪共享。</p>
<h3><a name="ringbuffer" id="ringbuffer"></a>RingBuffer</h3>
<p>RingBuffer是存储消息的地方，通过一个名为cursor的Sequence对象指示队列的头，协调多个生产者向RingBuffer中添加消息，并用于在消费者端判断RingBuffer是否为空。巧妙的是，队列尾并没有在RingBuffer中，而是由消费者维护。这样的好处是多个消费者处理消息的方式更加灵活，可以在一个RingBuffer上实现消息的单播，多播，流水线以及它们的组合。其缺点是在生产者端判断RingBuffer是否已满是需要跟踪更多的信息，为此，在RingBuffer中维护了一个名为gatingSequence的Sequence数组来跟踪相关Seqence。</p>
<h3><a name="sequencbarrier" id="sequencbarrier"></a>SequenceBarrier</h3>
<p>SequenceBarrier用来在消费者之间以及消费者和RingBuffer之间建立依赖关系。在Disruptor中，依赖关系实际上指的是Sequence的大小关系，消费者A依赖于消费者B指的是消费者A的Sequence一定要小于等于消费者B的Sequence，因为所有消费者都依赖于RingBuffer，所以消费者的Sequence一定小于等于RingBuffer中名为cursor的Sequence。</p>
<p>SequenceBarrier在初始化的时候会收集需要依赖的消费者的Sequence，RingBuffer的cursor会被自动的加入其中。需要依赖其他消费者和/或RingBuffer的消费者在消费下一个消息时，会先等待在SequenceBarrier上，直到所有被依赖的消费者和RingBuffer的Sequence大于等于这个消费者的Sequence。当被依赖的消费者或RingBuffer的Sequence有变化时，会通知SequenceBarrier唤醒等待在它上面的消费者。</p>
<h3><a name="waitstrategy" id="waitstrategy"></a>WaitStrategy</h3>
<p>当消费者等待在SequenceBarrier上时，有许多可选的等待策略，不同的等待策略在效率和CPU资源的占用上有所不同，可以视应用场景选择：</p>
<ul>
<li>BusySpinWaitStrategy</li>
<li>BlockingWaitStrategy</li>
<li>SleepingWaitStrategy</li>
<li>TimeoutBlockingWaitStrategy</li>
<li>YieldingWaitStrategy</li>
<li>PhasedBackoffWaitStrategy</li>
</ul>
<h3><a name="batcheventprocessor" id="batcheventprocessor"></a>BatchEvenProcessor</h3>
<p>在Disruptor中，消费者是以EventProcessor的形式存在的。其中一类消费者是BatchEvenProcessor。每个BatchEvenProcessor有一个Sequence，来记录自己消费RingBuffer中消息的情况。所以，一个消息必然会被每一个BatchEvenProcessor消费。</p>
<h3><a name="workprocessor" id="workprocessor"></a>WorkProcessor</h3>
<p>另一类消费者是WorkProcessor。每个WorkProcessor也有一个Sequence，多个WorkProcessor还共享一个Sequence用于互斥的访问RingBuffer。一个消息被一个WorkProcessor消费，就不会被共享一个Sequence的其他WorkProcessor消费。</p>
<h3><a name="workerpool" id="workerpool"></a>WorkerPool</h3>
<p>共享同一个Sequence的WorkProcessor可由一个WorkerPool管理，这时，共享的Sequence也由WorkerPool创建。</p>
<h2><a name="usecases" id="usecases"></a>Use Cases</h2>
<p>下面以Disruptor 3.2.0版本为例介绍Disruptor的初级使用方法，大部分代码是出自Disruptor源代码中得perftest部分(Disruptor代码<a href="https://github.com/LMAX-Exchange/disruptor">这里下载</a>)。</p>
<h3><a name="message" id="message"></a>消息定义</h3>
<p>Disruptor中消息对象可以自由定义，但是必须定义实现EventFactory<T>接口的消息对象工厂来告诉RingBuffer如何初始化消息对象。</p>
<div class="highlight"><pre><span class="k">public</span> <span class="nf">final</span> <span class="nb">class</span> <span class="nx">ValueEvent</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nf">long</span> <span class="nb">value</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">long</span> <span class="nx">getValue</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">void</span> <span class="nx">setValue</span><span class="p">(</span><span class="nx">final</span> <span class="nx">long</span> <span class="nb">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this.value</span> <span class="o">=</span> <span class="nb">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="nf">static</span> <span class="nx">final</span> <span class="nx">EventFactory</span><span class="o">&lt;</span><span class="nx">ValueEvent</span><span class="o">&gt;</span> <span class="n">EVENT_FACTORY</span> <span class="o">=</span> <span class="nb">new</span> <span class="nx">EventFactory</span><span class="o">&lt;</span><span class="nx">ValueEvent</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ValueEvent</span> <span class="nx">newInstance</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">new</span> <span class="nx">ValueEvent</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>


<h3><a name="producer" id="producer"></a>Producer</h3>
<p>Disruptor中同样没有定义生产者，而是由RingBuffer提供添加消息的接口。针对单生产者和多生产者两种应用场景，RingBuffer提供了不同的初始化方法：</p>
<ul>
<li>
<p>单生产者应用场景</p>
<div class="highlight"><pre><span class="k">private</span> <span class="nf">final</span> <span class="nx">RingBuffer</span><span class="o">&lt;</span><span class="nx">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
    <span class="nx">createSingleProducer</span><span class="p">(</span><span class="nx">ValueEvent.EVENT_FACTORY</span><span class="p">,</span> <span class="nx">BUFFER_SIZE</span><span class="p">,</span> <span class="nb">new</span> <span class="nx">YieldingWaitStrategy</span><span class="p">());</span>
</pre></div>


</li>
<li>
<p>多生产者应用场景</p>
<div class="highlight"><pre><span class="k">private</span> <span class="nf">final</span> <span class="nx">RingBuffer</span><span class="o">&lt;</span><span class="nx">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
    <span class="nx">createMultiProducer</span><span class="p">(</span><span class="nx">ValueEvent.EVENT_FACTORY</span><span class="p">,</span> <span class="nx">BUFFER_SIZE</span><span class="p">,</span> <span class="nb">new</span> <span class="nx">BusySpinWaitStrategy</span><span class="p">());</span>
</pre></div>


</li>
</ul>
<p>初始化的时候需要提供消息工厂，RingBuffer大小，以及一个选定的waitStrategy。向RingBuffer中添加消息的过程分成两阶段：1，申请可用节点，并将消息放入节点中；2，提交节点。</p>
<div class="highlight"><pre><span class="c1">// 阶段1：申请节点，并将消息放入节点中</span>
<span class="n">long</span> <span class="n">next</span> <span class="o">=</span> <span class="n">rb</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
<span class="n">rb</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">next</span><span class="p">).</span><span class="n">setValue</span><span class="p">(</span><span class="mh">0</span><span class="p">);</span>

<span class="c1">// 阶段2：提交节点</span>
<span class="n">rb</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
</pre></div>


<h3><a name="eventprocessor" id="eventprocessor"></a>EventProcessor及其依赖关系</h3>
<p>Disruptor定义了两种EventProcessor：BatchEventProcessor和WorkProcessor。两种EventProcessor都实现了Runnable接口，在组装完成后可以直接放入线程中执行。</p>
<p>用户需要实现自己的EventHandler来告诉EventProcessor在收到消息的时候怎样处理。</p>
<p>用户还需要结合SequenceBarrier来构造各个EventProcessor之间及其和RingBuffer之间的依赖，，关于依赖的定义，已经在上文解释过了。这里需要说明的是，我们在使用Queue构造pipeline的时候，类似于接水管，每一个步骤需要哪些处理，就用Queue接过去，处理完成后再用Queue接到下一个步骤。这种方式固然实现起来简单，但是消息需要穿过各个Queue，必要的时候还需要对消息进行复制，这会产生大量对Queue的并发访问操作，效率很低。在Disruptor里，相邻的两个步骤被解释成步骤2中的EventProcessor依赖步骤1中的EventProcessor，消息在RingBuffer中依次被步骤1中的EventProcessor和步骤2中的EventProcessor处理。</p>
<p>不仅EventProcessor对RingBuffer有依赖关系，RingBuffer对EventProcessor也有反向依赖。RingBuffer需要保证在生产者比消费者快得情况下，新生产的消息不会覆盖未被完全消费（即被所有EventProcessor处理）的消息。为了做到这一点，RingBuffer会追踪有依赖关系的EventProcessor中最小的Sequence（如果不能根据依赖关系判断Sequence大小，则全部追踪）。需要追踪的Sequence会加入到RingBuffer的gatingSequence数组中。下面通过几个use case说明两种EventProcessor和RingBuffer如何组装。</p>
<h3><a name="onepublishertoonebatcheventprocessor" id="onepublishertoonebatcheventprocessor"></a>One Producer to one BatchEventProcessor</h3>
<p>这是最简单的场景，一个BatchEventProcessor</p>
<div class="highlight"><pre><span class="c1">// 构造RingBuffer</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
    <span class="n">createSingleProducer</span><span class="p">(</span><span class="n">ValueEvent</span><span class="p">.</span><span class="no">EVENT_FACTORY</span><span class="p">,</span> <span class="no">BUFFER_SIZE</span><span class="p">,</span> <span class="k">new</span> <span class="n">YieldingWaitStrategy</span><span class="p">());</span>

<span class="c1">// 构造BatchEventProcessor 及依赖关系</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">SequenceBarrier</span> <span class="n">sequenceBarrier</span> <span class="o">=</span> <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">();</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">ValueAdditionEventHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueAdditionEventHandler</span><span class="p">();</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span> <span class="n">batchEventProcessor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span> <span class="n">sequenceBarrier</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span>

<span class="c1">// 构造反向依赖</span>
<span class="n">ringBuffer</span><span class="p">.</span><span class="n">addGatingSequences</span><span class="p">(</span><span class="n">batchEventProcessor</span><span class="p">.</span><span class="n">getSequence</span><span class="p">());</span>
</pre></div>


<h3><a name="onepublishertothreebatcheventprocessorspipeline" id="onepublishertothreebatcheventprocessorspipeline"></a>One Producer to three BatchEventProcessors Pipeline</h3>
<p>三个BatchEventProcessor构成一个pipeline，对一个消息先后进行加工。</p>
<div class="highlight"><pre><span class="c1">// 构造RingBuffer</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
    <span class="n">createSingleProducer</span><span class="p">(</span><span class="n">FunctionEvent</span><span class="p">.</span><span class="no">EVENT_FACTORY</span><span class="p">,</span> <span class="no">BUFFER_SIZE</span><span class="p">,</span> <span class="k">new</span> <span class="n">YieldingWaitStrategy</span><span class="p">());</span>

<span class="c1">// 构造BatchEventProcessor 及依赖关系</span>
<span class="c1">// stepOneBatchProcessor依赖RingBuffer</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">SequenceBarrier</span> <span class="n">stepOneSequenceBarrier</span> <span class="o">=</span> <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">();</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">FunctionEventHandler</span> <span class="n">stepOneFunctionHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FunctionEventHandler</span><span class="p">(</span><span class="n">FunctionStep</span><span class="p">.</span><span class="no">ONE</span><span class="p">);</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span> <span class="n">stepOneBatchProcessor</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span> <span class="n">stepOneSequenceBarrier</span><span class="p">,</span> <span class="n">stepOneFunctionHandler</span><span class="p">);</span>

<span class="c1">// stepTwoBatchProcessor依赖RingBuffer和stepOneBatchProcessor</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">SequenceBarrier</span> <span class="n">stepTwoSequenceBarrier</span> <span class="o">=</span> <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">(</span><span class="n">stepOneBatchProcessor</span><span class="p">.</span><span class="n">getSequence</span><span class="p">());</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">FunctionEventHandler</span> <span class="n">stepTwoFunctionHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FunctionEventHandler</span><span class="p">(</span><span class="n">FunctionStep</span><span class="p">.</span><span class="no">TWO</span><span class="p">);</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span> <span class="n">stepTwoBatchProcessor</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span> <span class="n">stepTwoSequenceBarrier</span><span class="p">,</span> <span class="n">stepTwoFunctionHandler</span><span class="p">);</span>

<span class="c1">// stepThreeBatchProcessor依赖RingBuffer和stepTwoBatchProcessor</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">SequenceBarrier</span> <span class="n">stepThreeSequenceBarrier</span> <span class="o">=</span> <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">(</span><span class="n">stepTwoBatchProcessor</span><span class="p">.</span><span class="n">getSequence</span><span class="p">());</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">FunctionEventHandler</span> <span class="n">stepThreeFunctionHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FunctionEventHandler</span><span class="p">(</span><span class="n">FunctionStep</span><span class="p">.</span><span class="no">THREE</span><span class="p">);</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span> <span class="n">stepThreeBatchProcessor</span> <span class="o">=</span>
    <span class="k">new</span> <span class="n">BatchEventProcessor</span><span class="o">&lt;</span><span class="n">FunctionEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span> <span class="n">stepThreeSequenceBarrier</span><span class="p">,</span> <span class="n">stepThreeFunctionHandler</span><span class="p">);</span>

<span class="c1">// 构造反向依赖，stepThreeBatchProcessor的Sequence最小</span>
<span class="n">ringBuffer</span><span class="p">.</span><span class="n">addGatingSequences</span><span class="p">(</span><span class="n">stepThreeBatchProcessor</span><span class="p">.</span><span class="n">getSequence</span><span class="p">());</span>
</pre></div>


<h3><a name="onepublishertothreebatcheventprocessorsmulticast" id="onepublishertothreebatcheventprocessorsmulticast"></a>One Producer to three BatchEventProcessors MultiCast</h3>
<p>一个消息被三个BatchEventProcessor处理，但没有先后关系。</p>
<div class="highlight"><pre><span class="c1">// 构造RingBuffer</span>
<span class="k">private</span> <span class="nf">final</span> <span class="nx">RingBuffer</span><span class="o">&lt;</span><span class="nx">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
    <span class="nx">createSingleProducer</span><span class="p">(</span><span class="nx">ValueEvent.EVENT_FACTORY</span><span class="p">,</span> <span class="nx">BUFFER_SIZE</span><span class="p">,</span> <span class="nb">new</span> <span class="nx">YieldingWaitStrategy</span><span class="p">());</span>

<span class="c1">// 构造BatchEventProcessor 及依赖关系</span>
<span class="k">private</span> <span class="nf">final</span> <span class="nx">SequenceBarrier</span> <span class="n">sequenceBarrier</span> <span class="o">=</span> <span class="nx">ringBuffer.newBarrier</span><span class="p">();</span>

<span class="k">private</span> <span class="nf">final</span> <span class="nx">ValueMutationEventHandler</span><span class="err">[</span><span class="cp">]</span> handlers = new ValueMutationEventHandler<span class="cp">[</span><span class="nx">NUM_EVENT_PROCESSORS</span><span class="cp">]</span>;

handlers<span class="cp">[</span><span class="mi">0</span><span class="cp">]</span> = new ValueMutationEventHandler(Operation.ADDITION);
handlers<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> = new ValueMutationEventHandler(Operation.SUBTRACTION);
handlers<span class="cp">[</span><span class="mi">2</span><span class="cp">]</span> = new ValueMutationEventHandler(Operation.AND);

private final BatchEventProcessor<span class="err">&lt;</span>?&gt;<span class="cp">[]</span> batchEventProcessors = new BatchEventProcessor<span class="cp">[</span><span class="mi">3</span><span class="cp">]</span>;

batchEventProcessors<span class="cp">[</span><span class="mi">0</span><span class="cp">]</span> = new BatchEventProcessor<span class="nt">&lt;ValueEvent&gt;</span>(ringBuffer, sequenceBarrier, handlers<span class="cp">[</span><span class="mi">0</span><span class="cp">]</span>);
batchEventProcessors<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span> = new BatchEventProcessor<span class="nt">&lt;ValueEvent&gt;</span>(ringBuffer, sequenceBarrier, handlers<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span>);
batchEventProcessors<span class="cp">[</span><span class="mi">2</span><span class="cp">]</span> = new BatchEventProcessor<span class="nt">&lt;ValueEvent&gt;</span>(ringBuffer, sequenceBarrier, handlers<span class="cp">[</span><span class="mi">2</span><span class="cp">]</span>);

// 构造反向依赖，三个EventProcessor没有依赖关系，将它们的Sequence全部加入
ringBuffer.addGatingSequences(batchEventProcessors<span class="cp">[</span><span class="mi">0</span><span class="cp">]</span>.getSequence(),
                              batchEventProcessors<span class="cp">[</span><span class="mi">1</span><span class="cp">]</span>.getSequence(),
                              batchEventProcessors<span class="cp">[</span><span class="mi">2</span><span class="cp">]</span>.getSequence());
</pre></div>


<h3><a name="onepublishertotwoworkprocessors" id="onepublishertotwoworkprocessors"></a>One Producer to two WorkProcessors</h3>
<p>一个消息只会被两个WorkProcessor中的一个处理。</p>
<div class="highlight"><pre><span class="c1">// 构造RingBuffer</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
        <span class="n">RingBuffer</span><span class="p">.</span><span class="n">createSingleProducer</span><span class="p">(</span><span class="n">ValueEvent</span><span class="p">.</span><span class="no">EVENT_FACTORY</span><span class="p">,</span>
                                        <span class="no">BUFFER_SIZE</span><span class="p">,</span>
                                        <span class="k">new</span> <span class="n">YieldingWaitStrategy</span><span class="p">());</span>

<span class="c1">// 构造拥有两个WorkProcessor的WorkerPool                                        </span>
<span class="n">private</span> <span class="k">final</span> <span class="n">EventCountingWorkHandler</span><span class="p">[]</span> <span class="n">handlers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventCountingWorkHandler</span><span class="p">[</span><span class="mh">2</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventCountingWorkHandler</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">private</span> <span class="k">final</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span> <span class="n">workerPool</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span>
                                   <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">(),</span>
                                   <span class="k">new</span> <span class="n">FatalExceptionHandler</span><span class="p">(),</span>
                                   <span class="n">handlers</span><span class="p">);</span>

<span class="c1">// 构造反向依赖</span>
<span class="n">ringBuffer</span><span class="p">.</span><span class="n">addGatingSequences</span><span class="p">(</span><span class="n">workerPool</span><span class="p">.</span><span class="n">getWorkerSequences</span><span class="p">());</span>
</pre></div>


<h3><a name="onepublishertotwoworkerpool" id="onepublishertotwoworkerpool"></a>One Producer to two WorkerPools</h3>
<p>一个消息会被两个WorkerPool中的WorkProcessor处理，但在一个WorkerPool中只能被一个WorkProcessor处理。</p>
<div class="highlight"><pre><span class="c1">// 构造RingBuffer</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">RingBuffer</span><span class="o">&lt;</span><span class="n">ValueEvent</span><span class="o">&gt;</span> <span class="n">ringBuffer</span> <span class="o">=</span>
        <span class="n">RingBuffer</span><span class="p">.</span><span class="n">createSingleProducer</span><span class="p">(</span><span class="n">ValueEvent</span><span class="p">.</span><span class="no">EVENT_FACTORY</span><span class="p">,</span>
                                        <span class="no">BUFFER_SIZE</span><span class="p">,</span>
                                        <span class="k">new</span> <span class="n">YieldingWaitStrategy</span><span class="p">());</span>

<span class="n">SequenceBarrier</span> <span class="n">barrier</span> <span class="o">=</span> <span class="n">ringBuffer</span><span class="p">.</span><span class="n">newBarrier</span><span class="p">();</span>

<span class="c1">// 构造拥有两个WorkProcessor的WorkerPool</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">EventCountingWorkHandler</span><span class="p">[]</span> <span class="n">handlers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventCountingWorkHandler</span><span class="p">[</span><span class="mh">4</span><span class="p">];</span>
<span class="k">for</span> <span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mh">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">handlers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EventCountingWorkHandler</span><span class="p">(</span><span class="n">counters</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">private</span> <span class="k">final</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">LesStringEvent</span><span class="o">&gt;</span> <span class="n">workerPool0</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">LesStringEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span>
                                       <span class="n">barrier</span><span class="p">,</span>
                                       <span class="k">new</span> <span class="n">FatalExceptionHandler</span><span class="p">(),</span>
                                       <span class="n">handlers</span><span class="p">[</span><span class="mh">0</span><span class="p">],</span> <span class="n">handlers</span><span class="p">[</span><span class="mh">1</span><span class="p">]);</span>
<span class="n">private</span> <span class="k">final</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">LesStringEvent</span><span class="o">&gt;</span> <span class="n">workerPool1</span> <span class="o">=</span>
        <span class="k">new</span> <span class="n">WorkerPool</span><span class="o">&lt;</span><span class="n">LesStringEvent</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ringBuffer</span><span class="p">,</span>
                                       <span class="n">barrier</span><span class="p">,</span>
                                       <span class="k">new</span> <span class="n">FatalExceptionHandler</span><span class="p">(),</span>
                                       <span class="n">handlers</span><span class="p">[</span><span class="mh">2</span><span class="p">],</span> <span class="n">handlers</span><span class="p">[</span><span class="mh">3</span><span class="p">]);</span>

<span class="c1">// 构造反向依赖</span>
<span class="n">ringBuffer</span><span class="p">.</span><span class="n">addGatingSequences</span><span class="p">(</span><span class="n">workerPool0</span><span class="p">.</span><span class="n">getWorkerSequences</span><span class="p">());</span>
<span class="n">ringBuffer</span><span class="p">.</span><span class="n">addGatingSequences</span><span class="p">(</span><span class="n">workerPool1</span><span class="p">.</span><span class="n">getWorkerSequences</span><span class="p">());</span>
</pre></div>


<h2><a name="end" id="end"></a>结束语</h2>
<p>本文主要讲述了Disruptor得基本使用方法，涉及少量对实现的解释，意在通过Disruptor的用用管窥Disruptor的设计思想。如果有时间，就再写一篇关于Disruptor实现的文章。本文没有涉及Disruptor定义的DSL（领域特定语言）接口，通过DSL可以更方便的使用Disruptor。</p>
            </div><!-- /.entry-content -->
                        <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "pages/2013/09/22/disruptor-use-manual.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://hanbinsblog.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>
            

        </div><!-- /.eleven.columns -->
        
     <div class="three columns">

<h4>Pages</h4>

 <ul>
            </ul>

<h4>Categories</h4>
<ul>
			<li><a href="../../../../category/java.html">Java</a></li>
	</ul>


<h4>Tags</h4>
	<ul>
		    <li class="tag-4"><a href="../../../../tag/bing-fa.html">并发</a></li>
		    <li class="tag-4"><a href="../../../../tag/disruptor.html">Disruptor</a></li>
	</ul>


<nav class="widget">
  <h4>Social</h4>
  <ul>
      <li><a href="http://www.linkedin.com/home?trk=nav_responsive_tab_home">Linkin</a></li>
    </ul>
</nav>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">

                                <li><div class="btn primary"><a href="https://github.com/ziyue1987" target="_blank">Github</a></div></li>
                
                
                
                
              </ul>
            </div>
          </div>
        </footer>

    </div>


<script type="text/javascript">
    var disqus_shortname = 'hanbinsblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="../../../../theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="../../../../theme/js/libs/gumby.min.js"></script>
  <script src="../../../../theme/js/plugins.js"></script>

</body>
</html>